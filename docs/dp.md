# Dynamic Programming
---

## 个人理解
> 动态规划 = 穷举 + 剪枝

动态规划的问题一般就是求最值，通过**穷举**列出所有可行答案，然后找出最值。很多问题其实都可以通过穷举来解决问题，但并不属于动态规划问题。辨别是否属于动态规划问题的关键在于，穷举过程中有没有存在大量的**重叠子**问题，同时这些子问题之间也应该是相互独立的。

因此，暴力穷举效率肯定会很低，那么如果通过其他办法消除这些**重叠子**效率自然也就会提升上去,消除**重叠子**的过程就是**剪枝**。

### 穷举方式：

1. **递归**
   
从root到leaf，即**由上而下**，通过`dp函数`表示`状态转移`，递归树的时间复杂度为O(k^n)。
使用「备忘录」在 **递归** 时过滤重叠子，时间复杂度由原来的`O(k^n)`降为`O(2^n)`，空间复杂度为`O(n)`。

2. **迭代**

从leaf到root的方式，即**由下而上**，创建一个的`DP数组`，通过`for循环`遍历`状态`,并将每个状态的结果放在`DP` 中, 一般结果都存放在数组末尾位置。迭代的时间复杂度`O(n)`(一个for循环时),空间复杂度`O(n)`，可以降为`O(1)`.


## 框架思维
 
> **确定状态** -> **明确选择** -> **动态转移方程** -> **Base Case** -> **状态压缩**

!> 注意dp数组的初始化与最终dp输出值 

有了框架思维，就可以进一步写出框架代码
```Swift
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

举例说明：
**高层扔鸡蛋**（一直记得几年前面试时答不上来的尴尬....

- 「状态」：`楼层N`和`鸡蛋K`，因为这些数量，都会在每次的测试发生改变。

- 「选择」：去哪个`楼层i`扔鸡蛋

- 「状态转移方程」：在鸡蛋扔出后，会出现两种状况，`碎`和`没碎`

    如果碎了，鸡蛋数`K - 1`,可选楼层数由原来的`[1...N]`变为`[1...i-1]`

    如果没碎，鸡蛋数`K`保持不变，可选楼层数由`[1...N]`变为`[i+1...N]`

明确了`状态`和`选择`，接下来通过`递归`的方式来表示状态的转移过程定义带有`状态参数`的`dp函数`，然后`for`循环遍历所有选择选取最优解。
```Swift
func dp(K, N) -> Int {
    for i in 1...N {
        res = min(res, i层扔鸡蛋)
    }
    return res
}
```
当然，也可以采用`迭代`方法来实现，这里`dp`数组的定义为二维数组，`dp[i][j]`表示当前当有`i`个鸡蛋在总楼层高为`j`时找到不碎楼层至少要尝试的次数。
```Swift
var dp = [K][N]
for i in 0...K {
    for j in 0...N {
        for k in 1...j {
            let worst = max[dp[i - 1][k - 1], dp[i][j - k]]
            dp[i][j] = min(dp[i][j], worst + 1)
        }
    }
}
return dp[K][N]
```



## 案例比较
对于动态规划系列的问题,这里列出几个比较热门的问题,并对所有问题进行对比,方便对动态规划更加深入理解.

|LeetCode|状态|DP含义|Base Case|动态方程|输出|
| - |- | - | - | - | - |
|[322.Coin Change](https://leetcode-cn.com/problems/coin-change/)|coin、amount|凑成金币总数i时最少需要dp[i]个不同金币|dp[0] = 0|dp[i] = min(dp[i], dp[i - coin] + 1)|dp[n]|
|[300.LIS](https://leetcode-cn.com/problems/longest-increasing-subsequence/)|len|以nums[i]结尾的最长上升子序列的长度|dp[0] = 1|dp[i] = max(dp[i], dp[j] + 1)|dp.max()|
|[279.Perfect Squares](https://leetcode-cn.com/problems/perfect-squares/)|sqrt、sum|组成和为i的最少完全平方数个数|dp[0] = 0|dp[i] = min(dp[i], dp[i - sqrt] + 1)|dp[n]|



